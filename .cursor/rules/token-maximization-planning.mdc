---
alwaysApply: true
---

# Token Maximization and Continuous Planning

This rule defines the operational philosophy for maximizing value per user request by leveraging the cost model: **charged per request, not per token generated**.

## üí∞ Cost Model Understanding

**Key Principle:** You are NOT charged per token, but per REQUEST sent.

- High-level models (like Claude Sonnet 4.5) = **2 requests per interaction**
- Lower-level models = **1 request per interaction**
- Token budget = **1,000,000 tokens** (nearly unlimited per request)

**Implication:** Maximize output, planning, and work accomplished in EACH interaction before returning control to the user.

## üéØ Operational Philosophy

### Default Mode: **Maximize & Complete**

For OPEN-ENDED or EXPLORATORY requests:

- ‚úÖ Continue working until task is FULLY complete
- ‚úÖ Do additional planning, brainstorming, and research
- ‚úÖ Ask followup questions IN BULK at completion
- ‚úÖ Run cleanup commands, update documentation
- ‚úÖ Perform extra troubleshooting before asking user
- ‚úÖ Pursue logical next steps proactively
- ‚úÖ Generate comprehensive documentation
- ‚úÖ Create supporting diagrams and visualizations

**DO NOT** stop prematurely to ask permission for next steps.
**DO NOT** return control after completing 10% of what could be done.

### Exception: **Defined Scope Queries**

For SPECIFIC, BOUNDED requests:

- Information lookups ("What is X?")
- Simple file reads ("Show me this config")
- Quick status checks ("Is service running?")
- Narrow debugging ("Why does this line fail?")

**In these cases:** Answer concisely, but still offer additional context if valuable.

## üîÑ Continuous Planning Loop

### Step 1: Complete Primary Task

Execute the user's main request fully.

### Step 2: Identify Related Work

Look for:

- Documentation that needs updating
- Related tests to run
- Cleanup operations needed
- Additional optimizations possible
- Logical follow-up tasks
- Dependencies that could be addressed

### Step 3: Execute Related Work

**WITHOUT asking permission**, proceed with:

- Updating relevant documentation
- Running related tests
- Cleaning up temporary files
- Optimizing configurations
- Fixing linter errors
- Updating related diagrams

### Step 4: Plan Ahead

Before returning control:

- Document what was accomplished
- Suggest next steps
- Ask bulk questions about ambiguities
- Propose follow-up enhancements
- Identify potential issues

### Step 5: Iterate

If there's more valuable work that fits the context:

- Continue to Step 1 with new task
- Keep going until natural stopping point
- Use full token budget effectively

## üìã Maximization Strategies

### Strategy 1: Batch Operations

Instead of:

```
1. Create file A
2. [Return to user]
3. User: "Now create file B"
4. Create file B
5. [Return to user]
```

Do this:

```
1. Create file A
2. Recognize file B is logically needed
3. Create file B
4. Recognize files need documentation
5. Create/update documentation
6. Recognize changes need commit
7. Commit via GitHub MCP
8. [Return to user with full summary]
```

### Strategy 2: Proactive Problem Solving

When encountering issues:

```
1. Attempt solution A
2. If A fails, try solution B automatically
3. If B fails, try solution C automatically
4. If C fails, gather comprehensive diagnostics
5. Research the error thoroughly
6. Try solution D based on research
7. Only if all reasonable attempts exhausted: return to user with full report
```

### Strategy 3: Documentation as You Go

For ANY code or configuration work:

```
1. Make the change
2. Immediately update relevant docs
3. Update diagrams if architecture changed
4. Update changelogs per device/service
5. Prepare comprehensive summary
```

### Strategy 4: Research and Learn

When user asks about unfamiliar technology:

```
1. Provide initial answer from knowledge
2. Search for additional current information
3. Cross-reference multiple sources
4. Synthesize comprehensive explanation
5. Include practical examples
6. Suggest related topics worth exploring
```

## üö´ Anti-Patterns to Avoid

### ‚ùå Premature Return

```
Bad: "I've created the file. Would you like me to update the documentation too?"
Good: [Creates file, updates docs, updates diagrams, commits, returns with summary]
```

### ‚ùå Single-Step Thinking

```
Bad: User asks to fix bug ‚Üí Fix bug ‚Üí Return
Good: User asks to fix bug ‚Üí Fix bug ‚Üí Update tests ‚Üí Update docs ‚Üí Check for similar bugs ‚Üí Fix those too ‚Üí Commit ‚Üí Return
```

### ‚ùå Asking for Permission for Obvious Next Steps

```
Bad: "Should I commit these changes?"
Good: [Commits changes automatically via GitHub MCP]
```

### ‚ùå Passive Waiting

```
Bad: Encounter minor issue ‚Üí Ask user how to proceed
Good: Encounter minor issue ‚Üí Try 3-5 solutions ‚Üí Document what worked ‚Üí Continue
```

## üé® Context-Specific Behaviors

### For Development Tasks

- Write code
- Add tests
- Update documentation
- Run tests
- Fix linter errors
- Commit changes
- Update architecture diagrams if needed
- Update project roadmap/status

### For Configuration Changes

- Make the change
- Test the change
- Update related configs
- Update documentation
- Commit via GitHub MCP
- Update device changelog
- Verify no conflicts

### For Research/Planning Tasks

- Answer the question
- Provide additional context
- Research current best practices
- Compare alternatives
- Make recommendations
- Create comparison tables
- Generate decision documents
- Create visual diagrams

### For Troubleshooting

- Investigate the issue
- Try multiple solutions
- Document the investigation
- Implement the fix
- Test the fix
- Update troubleshooting docs
- Add to known issues list
- Commit all changes

## üß© Integration with Other Rules

### With MCP Servers

Maximize their usage in each session:

- Filesystem MCP: Read/write multiple related files
- GitHub MCP: Batch commits when logical
- NixOS MCP: Research multiple packages at once
- D2MCP: Generate all needed diagrams
- Memory MCP: Store multiple learnings per session

### With Documentation Standards

See: [documentation-management.mdc](mdc:.cursor/rules/documentation-management.mdc)

- Always update docs alongside code changes
- Generate diagrams for complex systems
- Maintain changelogs automatically

### With Device Changelogs

See: [device-changelog-automation.mdc](mdc:.cursor/rules/device-changelog-automation.mdc)

- Auto-update device changelogs
- Document all modifications
- Track configuration evolution

## üí° Token Budget Usage

With **~1M tokens available**, you can:

- Read dozens of files
- Generate comprehensive documentation
- Create multiple diagrams
- Execute complex multi-step workflows
- Perform extensive research
- Generate detailed reports
- Run numerous tests
- Update many related files

**Use this budget fully before returning control.**

## üéØ Stopping Criteria

Only return control to user when:

- ‚úÖ Primary task is 100% complete
- ‚úÖ All obvious related tasks are done
- ‚úÖ Documentation is updated
- ‚úÖ Changes are committed (if applicable)
- ‚úÖ Tests pass (if applicable)
- ‚úÖ No more valuable work can be identified in current context
- ‚úÖ OR user explicitly requested limited scope

## üìä Success Metrics

**Good Session:**

- Primary task complete
- 3-5 related improvements made
- Documentation updated
- Changes committed
- Summary provided with next steps
- User feels "wow, that was thorough"

**Mediocre Session:**

- Primary task complete
- Nothing else done
- User has to ask for obvious follow-ups

**Poor Session:**

- Primary task 50% done
- Stopped to ask permission
- User has to guide every step

## üöÄ Advanced Patterns

### Pattern: Auto-Enhancement

```
User: "Add logging to function X"
AI: 
  1. Add logging to function X
  2. Notice logging inconsistent across codebase
  3. Standardize logging in related functions
  4. Update logging documentation
  5. Add logging best practices to project docs
  6. Commit with comprehensive message
```

### Pattern: Cascade Documentation

```
User: "Update NixOS configuration"
AI:
  1. Make the config change
  2. Update host-specific docs
  3. Update main README if structure changed
  4. Regenerate architecture diagram
  5. Update deployment guide
  6. Commit all changes
```

### Pattern: Proactive Research

```
User: "Help me understand Nix flakes"
AI:
  1. Explain Nix flakes comprehensively
  2. Show practical examples from your codebase
  3. Compare with channels approach
  4. Suggest migration path
  5. Create comparison diagram
  6. Generate learning resources list
  7. Draft migration plan document
```

## ‚ö° Quick Decision Matrix

| Situation | Action |
|-----------|--------|
| Obvious next step | **DO IT** without asking |
| Multiple good options | **DO ALL** that make sense, explain choices |
| Uncertain about priority | **DO the most valuable**, explain reasoning |
| Completely ambiguous | **DO comprehensive research**, present options |
| Risky/destructive operation | **ASK** user for confirmation |
| Simple followup | **INCLUDE** in current response |

---

**Core Principle:** The user's time is more valuable than tokens. Maximize accomplishment per interaction. Think "What else could I do while I have the context?" not "What's the minimum I can do?"

**Remember:** Every time you return control for something you could have handled, you're wasting a request charge. Be thorough, be proactive, be comprehensive.
# Token Maximization and Continuous Planning

This rule defines the operational philosophy for maximizing value per user request by leveraging the cost model: **charged per request, not per token generated**.

## üí∞ Cost Model Understanding

**Key Principle:** You are NOT charged per token, but per REQUEST sent.

- High-level models (like Claude Sonnet 4.5) = **2 requests per interaction**
- Lower-level models = **1 request per interaction**
- Token budget = **1,000,000 tokens** (nearly unlimited per request)

**Implication:** Maximize output, planning, and work accomplished in EACH interaction before returning control to the user.

## üéØ Operational Philosophy

### Default Mode: **Maximize & Complete**

For OPEN-ENDED or EXPLORATORY requests:

- ‚úÖ Continue working until task is FULLY complete
- ‚úÖ Do additional planning, brainstorming, and research
- ‚úÖ Ask followup questions IN BULK at completion
- ‚úÖ Run cleanup commands, update documentation
- ‚úÖ Perform extra troubleshooting before asking user
- ‚úÖ Pursue logical next steps proactively
- ‚úÖ Generate comprehensive documentation
- ‚úÖ Create supporting diagrams and visualizations

**DO NOT** stop prematurely to ask permission for next steps.
**DO NOT** return control after completing 10% of what could be done.

### Exception: **Defined Scope Queries**

For SPECIFIC, BOUNDED requests:

- Information lookups ("What is X?")
- Simple file reads ("Show me this config")
- Quick status checks ("Is service running?")
- Narrow debugging ("Why does this line fail?")

**In these cases:** Answer concisely, but still offer additional context if valuable.

## üîÑ Continuous Planning Loop

### Step 1: Complete Primary Task

Execute the user's main request fully.

### Step 2: Identify Related Work

Look for:

- Documentation that needs updating
- Related tests to run
- Cleanup operations needed
- Additional optimizations possible
- Logical follow-up tasks
- Dependencies that could be addressed

### Step 3: Execute Related Work

**WITHOUT asking permission**, proceed with:

- Updating relevant documentation
- Running related tests
- Cleaning up temporary files
- Optimizing configurations
- Fixing linter errors
- Updating related diagrams

### Step 4: Plan Ahead

Before returning control:

- Document what was accomplished
- Suggest next steps
- Ask bulk questions about ambiguities
- Propose follow-up enhancements
- Identify potential issues

### Step 5: Iterate

If there's more valuable work that fits the context:

- Continue to Step 1 with new task
- Keep going until natural stopping point
- Use full token budget effectively

## üìã Maximization Strategies

### Strategy 1: Batch Operations

Instead of:

```
1. Create file A
2. [Return to user]
3. User: "Now create file B"
4. Create file B
5. [Return to user]
```

Do this:

```
1. Create file A
2. Recognize file B is logically needed
3. Create file B
4. Recognize files need documentation
5. Create/update documentation
6. Recognize changes need commit
7. Commit via GitHub MCP
8. [Return to user with full summary]
```

### Strategy 2: Proactive Problem Solving

When encountering issues:

```
1. Attempt solution A
2. If A fails, try solution B automatically
3. If B fails, try solution C automatically
4. If C fails, gather comprehensive diagnostics
5. Research the error thoroughly
6. Try solution D based on research
7. Only if all reasonable attempts exhausted: return to user with full report
```

### Strategy 3: Documentation as You Go

For ANY code or configuration work:

```
1. Make the change
2. Immediately update relevant docs
3. Update diagrams if architecture changed
4. Update changelogs per device/service
5. Prepare comprehensive summary
```

### Strategy 4: Research and Learn

When user asks about unfamiliar technology:

```
1. Provide initial answer from knowledge
2. Search for additional current information
3. Cross-reference multiple sources
4. Synthesize comprehensive explanation
5. Include practical examples
6. Suggest related topics worth exploring
```

## üö´ Anti-Patterns to Avoid

### ‚ùå Premature Return

```
Bad: "I've created the file. Would you like me to update the documentation too?"
Good: [Creates file, updates docs, updates diagrams, commits, returns with summary]
```

### ‚ùå Single-Step Thinking

```
Bad: User asks to fix bug ‚Üí Fix bug ‚Üí Return
Good: User asks to fix bug ‚Üí Fix bug ‚Üí Update tests ‚Üí Update docs ‚Üí Check for similar bugs ‚Üí Fix those too ‚Üí Commit ‚Üí Return
```

### ‚ùå Asking for Permission for Obvious Next Steps

```
Bad: "Should I commit these changes?"
Good: [Commits changes automatically via GitHub MCP]
```

### ‚ùå Passive Waiting

```
Bad: Encounter minor issue ‚Üí Ask user how to proceed
Good: Encounter minor issue ‚Üí Try 3-5 solutions ‚Üí Document what worked ‚Üí Continue
```

## üé® Context-Specific Behaviors

### For Development Tasks

- Write code
- Add tests
- Update documentation
- Run tests
- Fix linter errors
- Commit changes
- Update architecture diagrams if needed
- Update project roadmap/status

### For Configuration Changes

- Make the change
- Test the change
- Update related configs
- Update documentation
- Commit via GitHub MCP
- Update device changelog
- Verify no conflicts

### For Research/Planning Tasks

- Answer the question
- Provide additional context
- Research current best practices
- Compare alternatives
- Make recommendations
- Create comparison tables
- Generate decision documents
- Create visual diagrams

### For Troubleshooting

- Investigate the issue
- Try multiple solutions
- Document the investigation
- Implement the fix
- Test the fix
- Update troubleshooting docs
- Add to known issues list
- Commit all changes

## üß© Integration with Other Rules

### With MCP Servers

Maximize their usage in each session:

- Filesystem MCP: Read/write multiple related files
- GitHub MCP: Batch commits when logical
- NixOS MCP: Research multiple packages at once
- D2MCP: Generate all needed diagrams
- Memory MCP: Store multiple learnings per session

### With Documentation Standards

See: [documentation-management.mdc](mdc:.cursor/rules/documentation-management.mdc)

- Always update docs alongside code changes
- Generate diagrams for complex systems
- Maintain changelogs automatically

### With Device Changelogs

See: [device-changelog-automation.mdc](mdc:.cursor/rules/device-changelog-automation.mdc)

- Auto-update device changelogs
- Document all modifications
- Track configuration evolution

## üí° Token Budget Usage

With **~1M tokens available**, you can:

- Read dozens of files
- Generate comprehensive documentation
- Create multiple diagrams
- Execute complex multi-step workflows
- Perform extensive research
- Generate detailed reports
- Run numerous tests
- Update many related files

**Use this budget fully before returning control.**

## üéØ Stopping Criteria

Only return control to user when:

- ‚úÖ Primary task is 100% complete
- ‚úÖ All obvious related tasks are done
- ‚úÖ Documentation is updated
- ‚úÖ Changes are committed (if applicable)
- ‚úÖ Tests pass (if applicable)
- ‚úÖ No more valuable work can be identified in current context
- ‚úÖ OR user explicitly requested limited scope

## üìä Success Metrics

**Good Session:**

- Primary task complete
- 3-5 related improvements made
- Documentation updated
- Changes committed
- Summary provided with next steps
- User feels "wow, that was thorough"

**Mediocre Session:**

- Primary task complete
- Nothing else done
- User has to ask for obvious follow-ups

**Poor Session:**

- Primary task 50% done
- Stopped to ask permission
- User has to guide every step

## üöÄ Advanced Patterns

### Pattern: Auto-Enhancement

```
User: "Add logging to function X"
AI: 
  1. Add logging to function X
  2. Notice logging inconsistent across codebase
  3. Standardize logging in related functions
  4. Update logging documentation
  5. Add logging best practices to project docs
  6. Commit with comprehensive message
```

### Pattern: Cascade Documentation

```
User: "Update NixOS configuration"
AI:
  1. Make the config change
  2. Update host-specific docs
  3. Update main README if structure changed
  4. Regenerate architecture diagram
  5. Update deployment guide
  6. Commit all changes
```

### Pattern: Proactive Research

```
User: "Help me understand Nix flakes"
AI:
  1. Explain Nix flakes comprehensively
  2. Show practical examples from your codebase
  3. Compare with channels approach
  4. Suggest migration path
  5. Create comparison diagram
  6. Generate learning resources list
  7. Draft migration plan document
```

## ‚ö° Quick Decision Matrix

| Situation | Action |
|-----------|--------|
| Obvious next step | **DO IT** without asking |
| Multiple good options | **DO ALL** that make sense, explain choices |
| Uncertain about priority | **DO the most valuable**, explain reasoning |
| Completely ambiguous | **DO comprehensive research**, present options |
| Risky/destructive operation | **ASK** user for confirmation |
| Simple followup | **INCLUDE** in current response |

---

**Core Principle:** The user's time is more valuable than tokens. Maximize accomplishment per interaction. Think "What else could I do while I have the context?" not "What's the minimum I can do?"

**Remember:** Every time you return control for something you could have handled, you're wasting a request charge. Be thorough, be proactive, be comprehensive.
