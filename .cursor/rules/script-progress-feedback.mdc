---
globs: *.py,*.sh
description: Script development standards requiring user feedback and progress indicators
---

# Script Progress Feedback and User Experience Standards

## ðŸŽ¯ Core Principle

**All scripts MUST provide clear, real-time feedback to the user about what's happening.**

Users should never wonder:

- â“ Is it running or frozen?
- â“ How long will this take?
- â“ What is it doing right now?
- â“ Did it crash or is it just slow?

---

## ðŸ“‹ Required Elements

### 1. **Startup Feedback** (Required)

Every script must print:

- Script name/purpose
- What it's about to do
- Any important parameters

```python
# Python Example
print("ðŸš€ Starting tech debt scan...")
print(f"ðŸ“ Scanning: {repo_root}")
print(f"âš™ï¸  Mode: {'full' if args.full else 'quick'}\n")
```

```bash
# Bash Example
echo "ðŸš€ Starting system backup..."
echo "ðŸ“ Source: $SOURCE_DIR"
echo "ðŸ’¾ Destination: $BACKUP_DIR"
echo ""
```

### 2. **Progress Indicators** (Required)

#### For Known-Length Operations

Use progress bars or percentage completion:

```python
# Python with progress bar
from tqdm import tqdm

for item in tqdm(items, desc="Processing files"):
    process(item)
```

```bash
# Bash with counter
total=${#files[@]}
current=0
for file in "${files[@]}"; do
    ((current++))
    echo "[$current/$total] Processing $file..."
    process_file "$file"
done
```

#### For Unknown-Length Operations

Use spinner or activity indicator:

```python
# Python spinner
import sys
import time

def long_operation():
    spinner = ['â ‹', 'â ™', 'â ¹', 'â ¸', 'â ¼', 'â ´', 'â ¦', 'â §', 'â ‡', 'â ']
    idx = 0
    while processing:
        sys.stdout.write(f'\r{spinner[idx % len(spinner)]} Processing...')
        sys.stdout.flush()
        idx += 1
        time.sleep(0.1)
    sys.stdout.write('\râœ… Complete!     \n')
```

```bash
# Bash spinner
spinner() {
    local pid=$1
    local delay=0.1
    local spinstr='â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â '
    while kill -0 $pid 2>/dev/null; do
        local temp=${spinstr#?}
        printf " [%c] " "$spinstr"
        spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    printf "    \b\b\b\b"
}

# Usage:
long_running_command &
spinner $!
echo "âœ… Complete!"
```

### 3. **Stage Announcements** (Required)

Print what stage the script is in:

```python
print("ðŸ” Scanning for hardcoded paths...")
# ... do work ...
print(f"  âœ… Found {count} hardcoded path references")

print("ðŸ” Scanning for TODO/FIXME comments...")
# ... do work ...
print(f"  âœ… Found {count} TODO/FIXME comments")
```

### 4. **Completion Status** (Required)

Always indicate final status:

```python
# Success
print("\nâœ… Scan complete!")
print(f"ðŸ“Š Processed {total} files in {duration:.2f}s")

# Failure
print("\nâŒ Scan failed!")
print(f"âš ï¸  Error: {error_message}")
sys.exit(1)
```

### 5. **Verbose/Debug Mode** (Recommended)

Provide optional verbose output:

```python
parser.add_argument('-v', '--verbose', action='store_true', 
                    help='Show detailed progress')

if args.verbose:
    print(f"  Processing {filename}...")
```

---

## ðŸš« Anti-Patterns to Avoid

### âŒ Silent Operation

```python
# BAD - no feedback
for file in files:
    process(file)
```

### âŒ Only Error Output

```python
# BAD - only shows when it fails
try:
    risky_operation()
except Exception as e:
    print(f"Error: {e}")
```

### âŒ Unclear Status

```python
# BAD - is it done or still running?
print("Processing...")
long_operation()  # No feedback during this
```

---

## âœ… Complete Examples

### Python Script Template with Progress

```python
#!/usr/bin/env python3
"""
Script with proper progress feedback
"""
import sys
import time
from pathlib import Path

def main():
    print("ðŸš€ Starting operation...")
    print(f"ðŸ“ Working directory: {Path.cwd()}")
    print()
    
    # Stage 1
    print("ðŸ” Stage 1: Scanning files...")
    files = scan_files()
    print(f"  âœ… Found {len(files)} files")
    
    # Stage 2 with progress
    print("ðŸ”¨ Stage 2: Processing files...")
    for i, file in enumerate(files, 1):
        print(f"  [{i}/{len(files)}] {file.name}...", end='\r')
        process_file(file)
    print(f"  âœ… Processed {len(files)} files" + " " * 30)
    
    # Stage 3
    print("ðŸ’¾ Stage 3: Saving results...")
    save_results()
    print("  âœ… Results saved")
    
    # Complete
    print("\nâœ… Operation complete!")
    print(f"ðŸ“Š Summary: {len(files)} files processed successfully")

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("\nâš ï¸  Operation cancelled by user")
        sys.exit(130)
    except Exception as e:
        print(f"\nâŒ Operation failed: {e}")
        sys.exit(1)
```

### Bash Script Template with Progress

```bash
#!/bin/bash
set -euo pipefail

# Colors for better visibility
GREEN='\033[0;32m'
BLUE='\033[0;34m'
RED='\033[0;31m'
NC='\033[0m' # No Color

echo -e "${BLUE}ðŸš€ Starting operation...${NC}"
echo "ðŸ“ Working directory: $(pwd)"
echo ""

# Stage 1
echo -e "${BLUE}ðŸ” Stage 1: Finding files...${NC}"
files=($(find . -name "*.txt"))
echo -e "  ${GREEN}âœ… Found ${#files[@]} files${NC}"

# Stage 2 with progress
echo -e "${BLUE}ðŸ”¨ Stage 2: Processing files...${NC}"
total=${#files[@]}
current=0
for file in "${files[@]}"; do
    ((current++))
    echo -ne "  [$current/$total] Processing $(basename "$file")...\r"
    # Do work here
    sleep 0.1
done
echo -e "  ${GREEN}âœ… Processed $total files${NC}          "

# Complete
echo ""
echo -e "${GREEN}âœ… Operation complete!${NC}"
echo "ðŸ“Š Summary: $total files processed successfully"
```

---

## ðŸŽ¨ Progress Indicators Reference

### Emoji Indicators

- ðŸš€ Starting/Launching
- ðŸ” Scanning/Searching
- ðŸ”¨ Processing/Building
- ðŸ’¾ Saving/Writing
- âœ… Success/Complete
- âŒ Error/Failure
- âš ï¸  Warning
- ðŸ“Š Results/Summary
- ðŸ“ Directory/Files
- â³ Waiting/Long operation
- ðŸ”„ Syncing/Updating

### Spinners (Unicode)

- `â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â ` - Braille dots
- `â—â—“â—‘â—’` - Circles
- `â†â†–â†‘â†—â†’â†˜â†“â†™` - Arrows
- `â£¾â£½â£»â¢¿â¡¿â£Ÿâ£¯â£·` - Growing dots

---

## ðŸ“ Best Practices

1. **Start immediately** - Print startup message before any delay
2. **Update regularly** - At least every 2-3 seconds for long operations
3. **Use color sparingly** - Don't rely on it (some terminals don't support it)
4. **Clear line endings** - Use `\r` for updates, `\n` for new lines
5. **Handle interrupts** - Catch Ctrl+C gracefully
6. **Show errors clearly** - Make failures obvious with âŒ or ERROR:
7. **Provide timing** - Show how long operations took
8. **Log to file** - For automated runs, also log to file

---

## ðŸ§ª Testing Checklist

Before committing any script, verify:

- [ ] Clear startup message appears immediately
- [ ] User knows what the script is doing at each stage
- [ ] Progress is visible for operations >3 seconds
- [ ] Completion status is clearly indicated
- [ ] Errors are caught and reported clearly
- [ ] Ctrl+C exits gracefully with message
- [ ] Works in non-interactive mode (cron, ssh)
- [ ] No ambiguous states (is it frozen or working?)

---

## ðŸ”— Related

- [scripts/README.md](mdc:scripts/README.md) - Script templates and standards
- [core/automation/README.md](mdc:core/automation/README.md) - Automation framework

---

**Remember:** Users should feel confident the script is working, not worried it's frozen! ðŸŽ¯
