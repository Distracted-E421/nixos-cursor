# NPM Security Module for nixos-cursor
# Provides defense-in-depth package verification for MCP servers
#
# Features:
# - Blocklist enforcement (known malicious packages)
# - Integrity verification via lockfiles
# - Sandboxed installation (optional)
# - Pre-installation scanning hooks

{ lib, pkgs, ... }:

let
  # Load the blocklist
  blocklist = builtins.fromJSON (builtins.readFile ./blocklists/known-malicious.json);

  # Extract all blocked package names (for quick lookup)
  extractBlockedPackages = category:
    if builtins.hasAttr "packages" (blocklist.packages.${category} or {})
    then map (p: p.name) blocklist.packages.${category}.packages
    else [];

  allBlockedPackages = lib.flatten (map extractBlockedPackages (builtins.attrNames blocklist.packages));

  # Indicators of compromise patterns from blocklist
  iocPatterns = blocklist.packages.shai_hulud_2025.indicators_of_compromise.postinstall_patterns or [];

in {
  # Export the blocklist for other modules to use
  inherit blocklist allBlockedPackages iocPatterns;

  # Check if a package is blocked
  isBlocked = packageName: version:
    let
      checkCategory = category:
        let
          packages = blocklist.packages.${category}.packages or [];
          matchingPackage = lib.findFirst (p: p.name == packageName) null packages;
        in
          if matchingPackage == null then false
          else if builtins.elem "*" matchingPackage.versions then true
          else builtins.elem version matchingPackage.versions;
    in
      lib.any checkCategory (builtins.attrNames blocklist.packages);

  # Get block reason for a package
  getBlockReason = packageName:
    let
      findInCategory = category:
        let
          packages = blocklist.packages.${category}.packages or [];
          matchingPackage = lib.findFirst (p: p.name == packageName) null packages;
        in
          if matchingPackage != null then matchingPackage.reason else null;
      
      reasons = lib.filter (r: r != null) (map findInCategory (builtins.attrNames blocklist.packages));
    in
      if reasons == [] then null else builtins.head reasons;

  # Create a secure npx wrapper that enforces blocklist and integrity
  mkSecureNpxWrapper = {
    name,
    package,
    lockfile ? null,
    extraArgs ? [],
    env ? {},
    allowPostinstall ? false,
  }: pkgs.writeShellScript "secure-mcp-${name}" ''
    #!/usr/bin/env bash
    set -euo pipefail

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # NPM Security Wrapper for: ${name}
    # Package: ${package}
    # Generated by nixos-cursor security module
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    # Color codes for output
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    NC='\033[0m' # No Color

    log_info() { echo -e "''${GREEN}[INFO]''${NC} $1"; }
    log_warn() { echo -e "''${YELLOW}[WARN]''${NC} $1" >&2; }
    log_error() { echo -e "''${RED}[ERROR]''${NC} $1" >&2; }

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Step 1: Blocklist Check
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    
    BLOCKLIST="${pkgs.writeText "npm-blocklist.txt" (lib.concatStringsSep "\n" allBlockedPackages)}"
    PACKAGE="${package}"
    
    # Check main package
    if grep -qxF "$PACKAGE" "$BLOCKLIST" 2>/dev/null; then
      log_error "BLOCKED: Package '$PACKAGE' is on the security blocklist!"
      log_error "This package is known to be malicious or compromised."
      log_error "If you believe this is an error, check:"
      log_error "  https://github.com/e421/nixos-cursor/security/blocklists/"
      exit 1
    fi

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Step 2: Environment Setup
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    
    # Non-interactive mode
    export NPM_CONFIG_YES=true
    export CI=true
    
    # Disable telemetry
    export DO_NOT_TRACK=1
    export npm_config_fund=false
    export npm_config_audit=false  # We do our own auditing
    
    ${lib.optionalString (!allowPostinstall) ''
    # Disable install scripts for security
    export npm_config_ignore_scripts=true
    ''}
    
    # Custom environment variables
    ${lib.concatStringsSep "\n" (lib.mapAttrsToList (k: v: "export ${k}=\"${v}\"") env)}

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Step 3: Integrity Verification (if lockfile provided)
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    
    ${lib.optionalString (lockfile != null) ''
    LOCKFILE="${lockfile}"
    CACHE_DIR="$HOME/.npm/_secure_cache/${name}"
    
    if [[ -f "$LOCKFILE" ]]; then
      log_info "Verifying package integrity from lockfile..."
      
      mkdir -p "$CACHE_DIR"
      
      # Check if we need to reinstall (lockfile changed)
      LOCKFILE_HASH=$(sha256sum "$LOCKFILE" | cut -d' ' -f1)
      CACHED_HASH=""
      [[ -f "$CACHE_DIR/.lockfile_hash" ]] && CACHED_HASH=$(cat "$CACHE_DIR/.lockfile_hash")
      
      if [[ "$LOCKFILE_HASH" != "$CACHED_HASH" ]] || [[ ! -d "$CACHE_DIR/node_modules" ]]; then
        log_info "Installing packages with integrity verification..."
        
        cd "$CACHE_DIR"
        cp "$LOCKFILE" package-lock.json
        echo '{"name":"secure-${name}","dependencies":{"${package}":"*"}}' > package.json
        
        # Use npm ci for strict lockfile adherence
        if ! ${pkgs.nodejs_22}/bin/npm ci ${lib.optionalString (!allowPostinstall) "--ignore-scripts"} 2>&1; then
          log_error "Integrity verification FAILED!"
          log_error "Package contents do not match expected hashes."
          log_error "This could indicate tampering. DO NOT PROCEED."
          exit 1
        fi
        
        echo "$LOCKFILE_HASH" > "$CACHE_DIR/.lockfile_hash"
        log_info "Integrity verification passed ‚úì"
      else
        log_info "Using cached packages (integrity verified)"
      fi
      
      cd "$CACHE_DIR"
    fi
    ''}

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Step 4: Run the MCP Server
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    
    ${if lockfile != null then ''
    # Run from verified cache
    exec ${pkgs.nodejs_22}/bin/npx --offline "${package}" ${lib.escapeShellArgs extraArgs} "$@"
    '' else ''
    # Run with npx (will download if needed)
    exec ${pkgs.nodejs_22}/bin/npx -y "${package}" ${lib.escapeShellArgs extraArgs} "$@"
    ''}
  '';

  # Generate a lockfile for a package
  generateLockfile = { package, outputPath }: pkgs.writeShellScript "generate-lockfile-${package}" ''
    #!/usr/bin/env bash
    set -euo pipefail

    PACKAGE="${package}"
    OUTPUT="${outputPath}"

    echo "Generating lockfile for $PACKAGE..."
    
    tmpdir=$(mktemp -d)
    cd "$tmpdir"
    
    # Create minimal package.json
    echo "{\"name\":\"lockfile-gen\",\"dependencies\":{\"$PACKAGE\":\"latest\"}}" > package.json
    
    # Generate lockfile with integrity hashes
    ${pkgs.nodejs_22}/bin/npm install --package-lock-only --ignore-scripts
    
    # Copy to output
    mkdir -p "$(dirname "$OUTPUT")"
    cp package-lock.json "$OUTPUT"
    
    # Cleanup
    rm -rf "$tmpdir"
    
    echo "‚úì Lockfile saved to: $OUTPUT"
    echo "  Packages locked: $(${pkgs.jq}/bin/jq '.packages | length' "$OUTPUT")"
  '';

  # Scan a package for suspicious patterns
  scanPackage = { package }: pkgs.writeShellScript "scan-${package}" ''
    #!/usr/bin/env bash
    set -euo pipefail

    PACKAGE="${package}"
    
    echo "üîç Scanning $PACKAGE for security issues..."
    echo ""
    
    # Create temp directory
    tmpdir=$(mktemp -d)
    cd "$tmpdir"
    
    # Download package without executing
    echo "üì¶ Downloading package metadata..."
    ${pkgs.nodejs_22}/bin/npm pack "$PACKAGE" --ignore-scripts 2>/dev/null || {
      echo "‚ùå Failed to download package"
      exit 1
    }
    
    # Extract
    tarball=$(ls *.tgz 2>/dev/null | head -1)
    if [[ -z "$tarball" ]]; then
      echo "‚ùå No tarball found"
      exit 1
    fi
    
    mkdir extracted
    tar -xzf "$tarball" -C extracted
    
    echo ""
    echo "üîé Checking for suspicious patterns..."
    
    SUSPICIOUS=0
    
    # Check for IOC patterns
    ${lib.concatMapStringsSep "\n" (pattern: ''
    if grep -rE "${pattern}" extracted/ 2>/dev/null; then
      echo "‚ö†Ô∏è  SUSPICIOUS: Found pattern matching '${pattern}'"
      SUSPICIOUS=1
    fi
    '') iocPatterns}
    
    # Check package.json for install scripts
    if [[ -f extracted/package/package.json ]]; then
      echo ""
      echo "üìã Checking install scripts..."
      
      scripts=$(${pkgs.jq}/bin/jq -r '.scripts // {} | keys[]' extracted/package/package.json 2>/dev/null)
      
      for script in $scripts; do
        case "$script" in
          preinstall|postinstall|preuninstall|postuninstall)
            echo "‚ö†Ô∏è  Has $script script:"
            ${pkgs.jq}/bin/jq -r ".scripts.$script" extracted/package/package.json
            SUSPICIOUS=1
            ;;
        esac
      done
    fi
    
    # Cleanup
    rm -rf "$tmpdir"
    
    echo ""
    if [[ $SUSPICIOUS -eq 0 ]]; then
      echo "‚úÖ No obvious suspicious patterns found"
      echo "   Note: This is a basic scan. Consider using Socket.dev or Snyk for deeper analysis."
    else
      echo "‚ö†Ô∏è  Suspicious patterns detected!"
      echo "   Review carefully before installing."
      exit 1
    fi
  '';

  # Create the cursor-security CLI tool
  securityCli = pkgs.writeShellScriptBin "cursor-security" ''
    #!/usr/bin/env bash
    set -euo pipefail

    SECURITY_DIR="${placeholder "out"}/share/nixos-cursor/security"
    LOCKFILE_DIR="''${XDG_DATA_HOME:-$HOME/.local/share}/nixos-cursor/lockfiles"
    
    usage() {
      cat <<EOF
    cursor-security - NPM package security for nixos-cursor

    USAGE:
      cursor-security <command> [options]

    COMMANDS:
      status              Show security status of installed MCP packages
      scan <package>      Scan a package for suspicious patterns
      check <package>     Check if a package is on the blocklist
      update-blocklist    Update the blocklist from upstream
      generate-lockfile   Generate lockfile for a package
      audit               Run npm audit on MCP packages

    OPTIONS:
      -h, --help          Show this help message
      -v, --verbose       Verbose output

    EXAMPLES:
      cursor-security status
      cursor-security scan @modelcontextprotocol/server-filesystem
      cursor-security check event-stream

    For more information, see:
      https://github.com/e421/nixos-cursor/docs/NPM_SECURITY_ARCHITECTURE.md
    EOF
    }

    case "''${1:-}" in
      status)
        echo "üîí NPM Security Status"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""
        echo "Blocklist version: ${blocklist.version}"
        echo "Last updated: ${blocklist.lastUpdated}"
        echo "Blocked packages: ${toString (builtins.length allBlockedPackages)}"
        echo ""
        echo "MCP Packages:"
        for pkg in "@modelcontextprotocol/server-filesystem" "@modelcontextprotocol/server-github" "@modelcontextprotocol/server-memory"; do
          if [[ -d "$LOCKFILE_DIR" ]] && ls "$LOCKFILE_DIR"/*"$(echo $pkg | tr '/@' '__')"* 2>/dev/null; then
            echo "  ‚úÖ $pkg (lockfile present)"
          else
            echo "  ‚ö†Ô∏è  $pkg (no lockfile)"
          fi
        done
        ;;
      
      scan)
        if [[ -z "''${2:-}" ]]; then
          echo "Usage: cursor-security scan <package>"
          exit 1
        fi
        # Inline scan implementation (can't reference scanPackage from within securityCli)
        PACKAGE="$2"
        echo "üîç Scanning $PACKAGE for security issues..."
        tmpdir=$(mktemp -d)
        cd "$tmpdir"
        echo "üì¶ Downloading package..."
        ${pkgs.nodejs_22}/bin/npm pack "$PACKAGE" --ignore-scripts 2>/dev/null || { echo "‚ùå Failed"; exit 1; }
        tarball=$(ls *.tgz 2>/dev/null | head -1)
        mkdir extracted && tar -xzf "$tarball" -C extracted
        echo "üîé Checking for suspicious patterns..."
        SUSPICIOUS=0
        if grep -rE 'process\.env\[.*(TOKEN|KEY|SECRET|PASSWORD)' extracted/ 2>/dev/null; then
          echo "‚ö†Ô∏è  Found credential access patterns"; SUSPICIOUS=1
        fi
        if grep -rE 'fs\.(readFile|readFileSync).*\.(ssh|aws|npmrc)' extracted/ 2>/dev/null; then
          echo "‚ö†Ô∏è  Found sensitive file access patterns"; SUSPICIOUS=1
        fi
        rm -rf "$tmpdir"
        if [[ $SUSPICIOUS -eq 0 ]]; then
          echo "‚úÖ No obvious suspicious patterns found"
        else
          echo "‚ö†Ô∏è  Review carefully before installing"
        fi
        ;;
      
      check)
        if [[ -z "''${2:-}" ]]; then
          echo "Usage: cursor-security check <package>"
          exit 1
        fi
        BLOCKLIST="${pkgs.writeText "blocklist" (lib.concatStringsSep "\n" allBlockedPackages)}"
        if grep -qxF "$2" "$BLOCKLIST"; then
          echo "‚ùå BLOCKED: $2 is on the blocklist"
          exit 1
        else
          echo "‚úÖ $2 is not on the blocklist"
        fi
        ;;
      
      generate-lockfile)
        if [[ -z "''${2:-}" ]]; then
          echo "Usage: cursor-security generate-lockfile <package>"
          exit 1
        fi
        mkdir -p "$LOCKFILE_DIR"
        safe_name=$(echo "$2" | tr '/@' '__')
        OUTPUT="$LOCKFILE_DIR/$safe_name.lock.json"
        PACKAGE="$2"
        echo "Generating lockfile for $PACKAGE..."
        tmpdir=$(mktemp -d)
        cd "$tmpdir"
        echo "{\"name\":\"lockfile-gen\",\"dependencies\":{\"$PACKAGE\":\"latest\"}}" > package.json
        ${pkgs.nodejs_22}/bin/npm install --package-lock-only --ignore-scripts
        mkdir -p "$(dirname "$OUTPUT")"
        cp package-lock.json "$OUTPUT"
        rm -rf "$tmpdir"
        echo "‚úì Lockfile saved to: $OUTPUT"
        ;;
      
      audit)
        echo "Running npm audit on cached MCP packages..."
        for dir in ~/.npm/_npx/*/; do
          if [[ -d "$dir/node_modules" ]]; then
            echo ""
            echo "Auditing: $dir"
            cd "$dir"
            ${pkgs.nodejs_22}/bin/npm audit 2>/dev/null || true
          fi
        done
        ;;
      
      update-blocklist)
        echo "Blocklist updates are managed via nixos-cursor flake updates."
        echo "Run: nix flake update in your configuration directory."
        ;;
      
      -h|--help|help|"")
        usage
        ;;
      
      *)
        echo "Unknown command: $1"
        usage
        exit 1
        ;;
    esac
  '';
}
