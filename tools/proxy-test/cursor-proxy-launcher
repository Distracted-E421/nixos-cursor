#!/usr/bin/env bash
#═══════════════════════════════════════════════════════════════════════════════
# Cursor Proxy Launcher - Painless AI Traffic Interception
#═══════════════════════════════════════════════════════════════════════════════
#
# Usage:
#   cursor-proxy-launcher                    # Launch default Cursor with proxy
#   cursor-proxy-launcher --version 2.3.10   # Launch specific version
#   cursor-proxy-launcher --no-proxy         # Launch without proxy (just CA trust)
#   cursor-proxy-launcher --setup            # First-time setup (generates CA)
#   cursor-proxy-launcher --status           # Show proxy status
#   cursor-proxy-launcher --cleanup          # Remove iptables rules
#
# What this does:
#   1. Ensures CA certificate exists (generates if needed)
#   2. Starts the Rust proxy if not running
#   3. Sets up iptables rules for transparent interception
#   4. Launches Cursor with NODE_EXTRA_CA_CERTS set
#   5. Cleans up iptables on exit
#
#═══════════════════════════════════════════════════════════════════════════════

set -euo pipefail

# ═══════════════════════════════════════════════════════════════════════════════
# Configuration
# ═══════════════════════════════════════════════════════════════════════════════

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
NIXOS_CURSOR_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"

# Paths
PROXY_DIR="$HOME/.cursor-proxy"
CA_CERT="$PROXY_DIR/ca-cert.pem"
CA_KEY="$PROXY_DIR/ca-key.pem"
PROXY_BIN="$SCRIPT_DIR/cursor-proxy/target/release/cursor-proxy"
PID_FILE="/tmp/cursor-proxy.pid"
LOG_FILE="/tmp/cursor-proxy.log"
CAPTURE_DIR="$SCRIPT_DIR/rust-captures"
IPTABLES_MARKER="/tmp/cursor-proxy-iptables-active"

# Settings
PROXY_PORT=8443
CURSOR_API_DOMAIN="api2.cursor.sh"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# ═══════════════════════════════════════════════════════════════════════════════
# Logging Functions
# ═══════════════════════════════════════════════════════════════════════════════

log()     { echo -e "${BLUE}[*]${NC} $1"; }
success() { echo -e "${GREEN}[✓]${NC} $1"; }
error()   { echo -e "${RED}[✗]${NC} $1"; }
warn()    { echo -e "${YELLOW}[!]${NC} $1"; }
info()    { echo -e "${CYAN}[i]${NC} $1"; }

header() {
    echo ""
    echo -e "${BOLD}╔════════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BOLD}║${NC}  ${CYAN}$1${NC}"
    echo -e "${BOLD}╚════════════════════════════════════════════════════════════════╝${NC}"
    echo ""
}

# ═══════════════════════════════════════════════════════════════════════════════
# CA Certificate Management
# ═══════════════════════════════════════════════════════════════════════════════

ensure_ca_exists() {
    if [[ -f "$CA_CERT" && -f "$CA_KEY" ]]; then
        # Verify cert is valid
        if openssl x509 -in "$CA_CERT" -noout -checkend 86400 2>/dev/null; then
            return 0
        else
            warn "CA certificate expired or invalid, regenerating..."
        fi
    fi
    
    generate_ca
}

generate_ca() {
    log "Generating new CA certificate..."
    
    mkdir -p "$PROXY_DIR"
    chmod 700 "$PROXY_DIR"
    
    # Generate ECDSA key (faster, smaller)
    openssl ecparam -genkey -name prime256v1 -out "$CA_KEY" 2>/dev/null
    
    # Generate self-signed CA cert (10 year validity)
    openssl req -new -x509 -key "$CA_KEY" -out "$CA_CERT" \
        -days 3650 \
        -subj "/CN=Cursor Proxy CA/O=Cursor Proxy" \
        -addext "basicConstraints=critical,CA:TRUE,pathlen:0" \
        -addext "keyUsage=critical,keyCertSign,cRLSign" \
        2>/dev/null
    
    chmod 600 "$CA_KEY"
    chmod 644 "$CA_CERT"
    
    success "CA certificate generated: $CA_CERT"
    
    # Check if we should add to system trust
    if command -v update-ca-certificates &>/dev/null; then
        info "To add to system trust (optional, for curl/wget):"
        echo "    sudo cp $CA_CERT /etc/ssl/certs/cursor-proxy-ca.pem"
        echo "    sudo update-ca-certificates"
    fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# Proxy Management
# ═══════════════════════════════════════════════════════════════════════════════

ensure_proxy_built() {
    if [[ ! -x "$PROXY_BIN" ]]; then
        log "Building proxy (first run only)..."
        
        if ! command -v cargo &>/dev/null; then
            # Try to use nix-shell for cargo
            if command -v nix-shell &>/dev/null; then
                (cd "$SCRIPT_DIR/cursor-proxy" && nix-shell -p cargo rustc --run "cargo build --release")
            else
                error "Cargo not found. Please install Rust or use nix-shell."
                exit 1
            fi
        else
            (cd "$SCRIPT_DIR/cursor-proxy" && cargo build --release 2>/dev/null)
        fi
        
        success "Proxy built successfully"
    fi
}

is_proxy_running() {
    [[ -f "$PID_FILE" ]] && kill -0 "$(cat "$PID_FILE")" 2>/dev/null
}

start_proxy() {
    if is_proxy_running; then
        info "Proxy already running (PID: $(cat "$PID_FILE"))"
        return 0
    fi
    
    log "Starting proxy on port $PROXY_PORT..."
    
    mkdir -p "$CAPTURE_DIR"
    
    # Start proxy in background
    "$PROXY_BIN" start \
        --port "$PROXY_PORT" \
        --ca-cert "$CA_CERT" \
        --ca-key "$CA_KEY" \
        --capture-dir "$CAPTURE_DIR" \
        > "$LOG_FILE" 2>&1 &
    
    local pid=$!
    echo "$pid" > "$PID_FILE"
    
    # Wait for proxy to be ready
    sleep 1
    
    if kill -0 "$pid" 2>/dev/null; then
        success "Proxy started (PID: $pid)"
        info "Logs: tail -f $LOG_FILE"
        info "Captures: $CAPTURE_DIR"
    else
        error "Proxy failed to start. Check $LOG_FILE"
        cat "$LOG_FILE" | tail -20
        exit 1
    fi
}

stop_proxy() {
    if [[ -f "$PID_FILE" ]]; then
        local pid
        pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            log "Stopping proxy (PID: $pid)..."
            kill "$pid" 2>/dev/null || true
            sleep 1
            kill -9 "$pid" 2>/dev/null || true
            success "Proxy stopped"
        fi
        rm -f "$PID_FILE"
    fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# iptables Management
# ═══════════════════════════════════════════════════════════════════════════════

get_cursor_ips() {
    dig +short "$CURSOR_API_DOMAIN" 2>/dev/null | grep -E '^[0-9]' || echo ""
}

setup_iptables() {
    log "Setting up iptables rules for transparent proxy..."
    
    local ips
    ips=$(get_cursor_ips)
    
    if [[ -z "$ips" ]]; then
        warn "Could not resolve $CURSOR_API_DOMAIN - DNS issue?"
        return 1
    fi
    
    local count=0
    for ip in $ips; do
        if ! sudo iptables -t nat -C OUTPUT -p tcp -d "$ip" --dport 443 -j REDIRECT --to-port "$PROXY_PORT" 2>/dev/null; then
            sudo iptables -t nat -A OUTPUT -p tcp -d "$ip" --dport 443 -j REDIRECT --to-port "$PROXY_PORT"
            ((count++))
        fi
    done
    
    # Mark that we set up iptables (for cleanup)
    echo "$ips" > "$IPTABLES_MARKER"
    
    success "iptables configured ($count new rules)"
}

cleanup_iptables() {
    log "Cleaning up iptables rules..."
    
    local count=0
    
    # Remove rules for current DNS IPs
    for ip in $(get_cursor_ips); do
        if sudo iptables -t nat -D OUTPUT -p tcp -d "$ip" --dport 443 -j REDIRECT --to-port "$PROXY_PORT" 2>/dev/null; then
            ((count++))
        fi
    done
    
    # Also remove rules for IPs we saved earlier (DNS may have changed)
    if [[ -f "$IPTABLES_MARKER" ]]; then
        for ip in $(cat "$IPTABLES_MARKER"); do
            sudo iptables -t nat -D OUTPUT -p tcp -d "$ip" --dport 443 -j REDIRECT --to-port "$PROXY_PORT" 2>/dev/null || true
        done
        rm -f "$IPTABLES_MARKER"
    fi
    
    # Aggressive cleanup: remove ANY rules pointing to our proxy port
    while sudo iptables -t nat -L OUTPUT -n 2>/dev/null | grep -q ":$PROXY_PORT"; do
        local rule_ip
        rule_ip=$(sudo iptables -t nat -L OUTPUT -n --line-numbers 2>/dev/null | grep ":$PROXY_PORT" | head -1 | awk '{print $5}')
        if [[ -n "$rule_ip" ]]; then
            sudo iptables -t nat -D OUTPUT -p tcp -d "$rule_ip" --dport 443 -j REDIRECT --to-port "$PROXY_PORT" 2>/dev/null || break
            ((count++))
        else
            break
        fi
    done
    
    success "iptables cleaned ($count rules removed)"
}

# ═══════════════════════════════════════════════════════════════════════════════
# Cursor Launcher
# ═══════════════════════════════════════════════════════════════════════════════

find_cursor_command() {
    local version="$1"
    
    if [[ -n "$version" ]]; then
        # Specific version requested - use flake
        local version_pkg="cursor-${version//./_}"
        if nix eval "$NIXOS_CURSOR_ROOT#$version_pkg" --raw 2>/dev/null; then
            echo "nix run $NIXOS_CURSOR_ROOT#$version_pkg --"
            return 0
        else
            error "Version $version not found in flake"
            return 1
        fi
    fi
    
    # Try system cursor first
    if command -v cursor &>/dev/null; then
        echo "cursor"
        return 0
    fi
    
    # Try flake default
    if [[ -f "$NIXOS_CURSOR_ROOT/flake.nix" ]]; then
        echo "nix run $NIXOS_CURSOR_ROOT#cursor --"
        return 0
    fi
    
    error "No Cursor installation found"
    return 1
}

launch_cursor() {
    local version="$1"
    shift
    local extra_args=("$@")
    
    local cursor_cmd
    cursor_cmd=$(find_cursor_command "$version")
    
    log "Launching Cursor with proxy CA trust..."
    info "NODE_EXTRA_CA_CERTS=$CA_CERT"
    
    # Export environment for Cursor
    export NODE_EXTRA_CA_CERTS="$CA_CERT"
    export SSL_CERT_FILE="$CA_CERT"
    export REQUESTS_CA_BUNDLE="$CA_CERT"
    
    # Launch Cursor
    if [[ ${#extra_args[@]} -gt 0 ]]; then
        exec $cursor_cmd "${extra_args[@]}"
    else
        exec $cursor_cmd
    fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# Cleanup Handler
# ═══════════════════════════════════════════════════════════════════════════════

cleanup_on_exit() {
    echo ""
    log "Cursor closed, cleaning up..."
    cleanup_iptables
    # Don't stop proxy - user might want to review captures
    info "Proxy still running. Stop with: $0 --cleanup"
}

# ═══════════════════════════════════════════════════════════════════════════════
# Status Display
# ═══════════════════════════════════════════════════════════════════════════════

show_status() {
    header "Cursor Proxy Status"
    
    # Proxy status
    if is_proxy_running; then
        echo -e "  ${GREEN}●${NC} Proxy: Running (PID: $(cat "$PID_FILE"))"
    else
        echo -e "  ${RED}●${NC} Proxy: Not running"
    fi
    
    # CA certificate
    if [[ -f "$CA_CERT" ]]; then
        local expiry
        expiry=$(openssl x509 -in "$CA_CERT" -noout -enddate 2>/dev/null | cut -d= -f2)
        echo -e "  ${GREEN}●${NC} CA Certificate: Valid until $expiry"
        echo -e "    Path: $CA_CERT"
    else
        echo -e "  ${RED}●${NC} CA Certificate: Not found"
    fi
    
    # iptables
    local rule_count
    rule_count=$(sudo iptables -t nat -L OUTPUT -n 2>/dev/null | grep -c ":$PROXY_PORT" || echo 0)
    if [[ "$rule_count" -gt 0 ]]; then
        echo -e "  ${GREEN}●${NC} iptables: $rule_count rules active"
    else
        echo -e "  ${YELLOW}●${NC} iptables: No rules active"
    fi
    
    # Captures
    if [[ -d "$CAPTURE_DIR" ]]; then
        local capture_count
        capture_count=$(find "$CAPTURE_DIR" -name "*.bin" 2>/dev/null | wc -l)
        echo -e "  ${CYAN}●${NC} Captured streams: $capture_count"
    fi
    
    echo ""
    
    # Recent log entries
    if [[ -f "$LOG_FILE" ]]; then
        echo -e "${BOLD}Recent Log Entries:${NC}"
        tail -10 "$LOG_FILE" 2>/dev/null | sed 's/^/  /'
    fi
    
    echo ""
}

# ═══════════════════════════════════════════════════════════════════════════════
# Main
# ═══════════════════════════════════════════════════════════════════════════════

usage() {
    cat << EOF
${BOLD}Cursor Proxy Launcher${NC} - Painless AI Traffic Interception

${BOLD}Usage:${NC}
  $(basename "$0") [OPTIONS] [-- CURSOR_ARGS...]

${BOLD}Options:${NC}
  --version VER    Launch specific Cursor version (e.g., 2.3.10)
  --no-proxy       Launch with CA trust but without proxy/iptables
  --setup          First-time setup (generate CA, build proxy)
  --status         Show proxy status
  --cleanup        Stop proxy and remove iptables rules
  --help           Show this help

${BOLD}Examples:${NC}
  $(basename "$0")                      # Launch default Cursor with full proxy
  $(basename "$0") --version 2.0.77     # Launch specific version
  $(basename "$0") --no-proxy           # Just CA trust, no interception
  $(basename "$0") -- --new-window      # Pass args to Cursor

${BOLD}What happens:${NC}
  1. Generates CA certificate (if needed)
  2. Builds Rust proxy (first run only)
  3. Starts proxy on port $PROXY_PORT
  4. Sets up iptables for $CURSOR_API_DOMAIN
  5. Launches Cursor with NODE_EXTRA_CA_CERTS
  6. Cleans up iptables when Cursor exits

${BOLD}Files:${NC}
  CA Cert:  $CA_CERT
  Logs:     $LOG_FILE
  Captures: $CAPTURE_DIR

EOF
}

main() {
    local version=""
    local no_proxy=false
    local cursor_args=()
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --version|-v)
                version="$2"
                shift 2
                ;;
            --no-proxy)
                no_proxy=true
                shift
                ;;
            --setup)
                header "First-Time Setup"
                ensure_ca_exists
                ensure_proxy_built
                success "Setup complete! Run without --setup to launch Cursor."
                exit 0
                ;;
            --status)
                show_status
                exit 0
                ;;
            --cleanup)
                header "Cleanup"
                cleanup_iptables
                stop_proxy
                success "Cleanup complete"
                exit 0
                ;;
            --help|-h)
                usage
                exit 0
                ;;
            --)
                shift
                cursor_args=("$@")
                break
                ;;
            *)
                cursor_args+=("$1")
                shift
                ;;
        esac
    done
    
    header "Cursor Proxy Launcher"
    
    # Step 1: Ensure CA exists
    ensure_ca_exists
    
    if [[ "$no_proxy" == true ]]; then
        # Just launch with CA trust, no proxy
        info "Launching without proxy (CA trust only)"
        launch_cursor "$version" "${cursor_args[@]}"
    else
        # Full proxy mode
        ensure_proxy_built
        start_proxy
        setup_iptables
        
        # Set up cleanup trap
        trap cleanup_on_exit EXIT INT TERM
        
        echo ""
        info "Monitor traffic: tail -f $LOG_FILE"
        info "View captures:   ls $CAPTURE_DIR"
        echo ""
        
        launch_cursor "$version" "${cursor_args[@]}"
    fi
}

main "$@"

