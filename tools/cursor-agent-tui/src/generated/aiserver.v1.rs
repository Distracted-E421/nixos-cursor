// This file is @generated by prost-build.
/// Main request wrapper with tools support
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamUnifiedChatRequestWithTools {
    /// Field 1: The main chat request
    #[prost(message, optional, tag = "1")]
    pub stream_unified_chat_request: ::core::option::Option<StreamUnifiedChatRequest>,
    /// Field 2: Results from client-side tool execution
    #[prost(message, optional, tag = "2")]
    pub client_side_tool_v2_result: ::core::option::Option<ClientSideToolV2Result>,
}
/// The core chat request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamUnifiedChatRequest {
    /// Field 1: Conversation history
    #[prost(message, repeated, tag = "1")]
    pub conversation: ::prost::alloc::vec::Vec<ConversationMessage>,
    /// Field 30: Full conversation headers (metadata only)
    #[prost(message, repeated, tag = "30")]
    pub full_conversation_headers_only: ::prost::alloc::vec::Vec<
        ConversationMessageHeader,
    >,
    /// Field 2: Allow scanning long files
    #[prost(bool, tag = "2")]
    pub allow_long_file_scan: bool,
    /// Field 3: Explicitly provided context
    #[prost(message, optional, tag = "3")]
    pub explicit_context: ::core::option::Option<ExplicitContext>,
    /// Field 4: Client can handle filenames after language IDs
    #[prost(bool, tag = "4")]
    pub can_handle_filenames_after_language_ids: bool,
    /// Field 5: Model selection and configuration
    #[prost(message, optional, tag = "5")]
    pub model_details: ::core::option::Option<ModelDetails>,
    /// Field 6: Linter errors in context
    #[prost(message, optional, tag = "6")]
    pub linter_errors: ::core::option::Option<LinterErrors>,
    /// Field 7: Documentation identifiers to include
    #[prost(string, tag = "7")]
    pub documentation_identifiers: ::prost::alloc::string::String,
    /// Field 8: Enable web search
    #[prost(string, tag = "8")]
    pub use_web: ::prost::alloc::string::String,
    /// Field 9: External links
    #[prost(message, repeated, tag = "9")]
    pub external_links: ::prost::alloc::vec::Vec<ComposerExternalLink>,
    /// Field 10: Project context
    #[prost(message, repeated, tag = "10")]
    pub project_context: ::prost::alloc::vec::Vec<ConversationMessage>,
    /// Field 11: Diffs for compressing files
    #[prost(message, repeated, tag = "11")]
    pub diffs_for_compressing_files: ::prost::alloc::vec::Vec<FileDiffForCompression>,
    /// Field 12: Compress edits
    #[prost(bool, tag = "12")]
    pub compress_edits: bool,
    /// Field 13: Enable caching
    #[prost(bool, tag = "13")]
    pub should_cache: bool,
    /// Field 14: Multi-file linter errors
    #[prost(message, repeated, tag = "14")]
    pub multi_file_linter_errors: ::prost::alloc::vec::Vec<LinterErrors>,
    /// Field 15: Current file information
    #[prost(message, optional, tag = "15")]
    pub current_file: ::core::option::Option<CurrentFileInfo>,
    /// Field 16: Recent edits
    #[prost(message, optional, tag = "16")]
    pub recent_edits: ::core::option::Option<stream_unified_chat_request::RecentEdits>,
    /// Field 17: Use reference composer diff prompt
    #[prost(bool, tag = "17")]
    pub use_reference_composer_diff_prompt: bool,
    /// Field 18: File diff histories
    #[prost(message, repeated, tag = "18")]
    pub file_diff_histories: ::prost::alloc::vec::Vec<FileDiffHistory>,
    /// Field 19: Use new compression scheme
    #[prost(bool, tag = "19")]
    pub use_new_compression_scheme: bool,
    /// Field 20: Additional ranked context
    #[prost(message, repeated, tag = "20")]
    pub additional_ranked_context: ::prost::alloc::vec::Vec<AdditionalRankedContext>,
    /// Field 21: Chat quotes
    #[prost(message, repeated, tag = "21")]
    pub quotes: ::prost::alloc::vec::Vec<ChatQuote>,
    /// Field 22: Is this a chat (vs composer)
    #[prost(bool, tag = "22")]
    pub is_chat: bool,
    /// Field 23: Conversation ID
    #[prost(string, tag = "23")]
    pub conversation_id: ::prost::alloc::string::String,
    /// Field 72: Replying to a specific request
    #[prost(string, tag = "72")]
    pub replying_to_request_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `StreamUnifiedChatRequest`.
pub mod stream_unified_chat_request {
    /// Nested message types
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RecentEdits {
        #[prost(message, repeated, tag = "1")]
        pub code_blocks: ::prost::alloc::vec::Vec<recent_edits::CodeBlockInfo>,
        #[prost(message, repeated, tag = "2")]
        pub files: ::prost::alloc::vec::Vec<recent_edits::FileInfo>,
    }
    /// Nested message and enum types in `RecentEdits`.
    pub mod recent_edits {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CodeBlockInfo {
            #[prost(string, tag = "1")]
            pub file_path: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub content: ::prost::alloc::string::String,
            #[prost(int32, tag = "3")]
            pub start_line: i32,
            #[prost(int32, tag = "4")]
            pub end_line: i32,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FileInfo {
            #[prost(string, tag = "1")]
            pub path: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub language_id: ::prost::alloc::string::String,
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FullFileCmdKOptions {
        #[prost(bool, tag = "1")]
        pub enabled: bool,
        #[prost(string, tag = "2")]
        pub mode: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CodeSearchResult {
        #[prost(string, tag = "1")]
        pub file_path: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub content: ::prost::alloc::string::String,
        #[prost(float, tag = "3")]
        pub score: f32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RedDiff {
        #[prost(string, tag = "1")]
        pub file_path: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub diff: ::prost::alloc::string::String,
    }
    /// Enums for mode selection
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UnifiedMode {
        Unspecified = 0,
        Chat = 1,
        Composer = 2,
        CmdK = 3,
    }
    impl UnifiedMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNIFIED_MODE_UNSPECIFIED",
                Self::Chat => "UNIFIED_MODE_CHAT",
                Self::Composer => "UNIFIED_MODE_COMPOSER",
                Self::CmdK => "UNIFIED_MODE_CMD_K",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNIFIED_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "UNIFIED_MODE_CHAT" => Some(Self::Chat),
                "UNIFIED_MODE_COMPOSER" => Some(Self::Composer),
                "UNIFIED_MODE_CMD_K" => Some(Self::CmdK),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ThinkingLevel {
        Unspecified = 0,
        None = 1,
        Basic = 2,
        Extended = 3,
    }
    impl ThinkingLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "THINKING_LEVEL_UNSPECIFIED",
                Self::None => "THINKING_LEVEL_NONE",
                Self::Basic => "THINKING_LEVEL_BASIC",
                Self::Extended => "THINKING_LEVEL_EXTENDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "THINKING_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
                "THINKING_LEVEL_NONE" => Some(Self::None),
                "THINKING_LEVEL_BASIC" => Some(Self::Basic),
                "THINKING_LEVEL_EXTENDED" => Some(Self::Extended),
                _ => None,
            }
        }
    }
}
/// Idempotent request variant
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamUnifiedChatRequestWithToolsIdempotent {
    /// Field 1: Client chunk containing the request
    #[prost(message, optional, tag = "1")]
    pub client_chunk: ::core::option::Option<ClientChunk>,
    /// Field 2: Abort signal (empty message)
    #[prost(message, optional, tag = "2")]
    pub abort: ::core::option::Option<AbortSignal>,
    /// Field 3: Close signal (empty message)
    #[prost(message, optional, tag = "3")]
    pub close: ::core::option::Option<CloseSignal>,
    /// Field 4: Idempotency key
    #[prost(string, tag = "4")]
    pub idempotency_key: ::prost::alloc::string::String,
    /// Field 5: Sequence number
    #[prost(int64, tag = "5")]
    pub seqno: i64,
}
/// Signal messages (replacing google.protobuf.Empty)
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbortSignal {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CloseSignal {}
/// Main response wrapper with tools
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamUnifiedChatResponseWithTools {
    /// Field 1: Tool call from server
    #[prost(message, optional, tag = "1")]
    pub client_side_tool_v2_call: ::core::option::Option<ClientSideToolV2Call>,
    /// Field 2: The actual chat response
    #[prost(message, optional, tag = "2")]
    pub stream_unified_chat_response: ::core::option::Option<StreamUnifiedChatResponse>,
    /// Field 3: Conversation summary
    #[prost(message, optional, tag = "3")]
    pub conversation_summary: ::core::option::Option<ConversationSummary>,
    /// Field 4: User rules applied
    #[prost(message, optional, tag = "4")]
    pub user_rules: ::core::option::Option<UserRules>,
    /// Field 5: Stream start marker
    #[prost(message, optional, tag = "5")]
    pub stream_start: ::core::option::Option<StreamStart>,
    /// Field 6: Tracing context
    #[prost(message, optional, tag = "6")]
    pub tracing_context: ::core::option::Option<SpanContext>,
    /// Field 7: Event ID
    #[prost(string, tag = "7")]
    pub event_id: ::prost::alloc::string::String,
}
/// The core chat response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamUnifiedChatResponse {
    /// Field 1: Response text (streamed)
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    /// Field 2: Final tool results
    #[prost(message, repeated, tag = "2")]
    pub final_tool_results: ::prost::alloc::vec::Vec<
        stream_unified_chat_response::FinalToolResult,
    >,
    /// Field 3: Image descriptions
    #[prost(message, repeated, tag = "3")]
    pub image_descriptions: ::prost::alloc::vec::Vec<
        stream_unified_chat_response::ImageDescription,
    >,
    /// Field 4: Used code references
    #[prost(message, repeated, tag = "4")]
    pub used_code: ::prost::alloc::vec::Vec<stream_unified_chat_response::UsedCode>,
    /// Field 5: Chunk identity
    #[prost(message, optional, tag = "5")]
    pub chunk_identity: ::core::option::Option<
        stream_unified_chat_response::ChunkIdentity,
    >,
}
/// Nested message and enum types in `StreamUnifiedChatResponse`.
pub mod stream_unified_chat_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FinalToolResult {
        #[prost(string, tag = "1")]
        pub tool_name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub result: ::prost::alloc::string::String,
        #[prost(bool, tag = "3")]
        pub success: bool,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ImageDescription {
        #[prost(string, tag = "1")]
        pub image_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub description: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UsedCode {
        #[prost(string, tag = "1")]
        pub file_path: ::prost::alloc::string::String,
        #[prost(int32, tag = "2")]
        pub start_line: i32,
        #[prost(int32, tag = "3")]
        pub end_line: i32,
        #[prost(string, tag = "4")]
        pub content: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ChunkIdentity {
        #[prost(string, tag = "1")]
        pub chunk_id: ::prost::alloc::string::String,
        #[prost(int32, tag = "2")]
        pub index: i32,
    }
}
/// Idempotent response variant
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamUnifiedChatResponseWithToolsIdempotent {
    #[prost(message, optional, tag = "1")]
    pub response: ::core::option::Option<StreamUnifiedChatResponseWithTools>,
    #[prost(int64, tag = "2")]
    pub seqno: i64,
    #[prost(bool, tag = "3")]
    pub is_final: bool,
}
/// A single message in a conversation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversationMessage {
    /// Field 1: Message text content
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    /// Field 2: Message type (user/assistant/system)
    #[prost(enumeration = "conversation_message::MessageType", tag = "2")]
    pub r#type: i32,
    /// Field 3: Attached code chunks
    #[prost(message, repeated, tag = "3")]
    pub attached_code_chunks: ::prost::alloc::vec::Vec<conversation_message::CodeChunk>,
    /// Field 4: Codebase context chunks
    #[prost(message, repeated, tag = "4")]
    pub codebase_context_chunks: ::prost::alloc::vec::Vec<CodeBlock>,
    /// Field 5: Commit references
    #[prost(message, repeated, tag = "5")]
    pub commits: ::prost::alloc::vec::Vec<CommitReference>,
    /// Field 6: Pull request references
    #[prost(message, repeated, tag = "6")]
    pub pull_requests: ::prost::alloc::vec::Vec<PullRequestReference>,
    /// Field 7: Git diffs
    #[prost(message, repeated, tag = "7")]
    pub git_diffs: ::prost::alloc::vec::Vec<GitDiff>,
    /// Field 8: Assistant suggested diffs
    #[prost(message, repeated, tag = "8")]
    pub assistant_suggested_diffs: ::prost::alloc::vec::Vec<SuggestedDiff>,
    /// Field 9: Interpreter results
    #[prost(message, repeated, tag = "9")]
    pub interpreter_results: ::prost::alloc::vec::Vec<InterpreterResult>,
    /// Field 10: Images
    #[prost(message, repeated, tag = "10")]
    pub images: ::prost::alloc::vec::Vec<ImageProto>,
    /// Field 11: Attached folder paths
    #[prost(string, repeated, tag = "11")]
    pub attached_folders: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Field 12: Approximate lint errors
    #[prost(message, repeated, tag = "12")]
    pub approximate_lint_errors: ::prost::alloc::vec::Vec<
        conversation_message::ApproximateLintError,
    >,
    /// Field 13: Bubble ID (unique message ID)
    #[prost(string, tag = "13")]
    pub bubble_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ConversationMessage`.
pub mod conversation_message {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CodeChunk {
        #[prost(string, tag = "1")]
        pub file_path: ::prost::alloc::string::String,
        #[prost(int32, tag = "2")]
        pub start_line: i32,
        #[prost(int32, tag = "3")]
        pub end_line: i32,
        #[prost(string, tag = "4")]
        pub content: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub language_id: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "6")]
        pub git_context: ::core::option::Option<code_chunk::CodeChunkGitContext>,
    }
    /// Nested message and enum types in `CodeChunk`.
    pub mod code_chunk {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CodeChunkGitContext {
            #[prost(message, repeated, tag = "1")]
            pub git_info: ::prost::alloc::vec::Vec<
                code_chunk_git_context::CodeChunkGitInfo,
            >,
        }
        /// Nested message and enum types in `CodeChunkGitContext`.
        pub mod code_chunk_git_context {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct CodeChunkGitInfo {
                #[prost(string, tag = "1")]
                pub commit_sha: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub branch_name: ::prost::alloc::string::String,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ApproximateLintError {
        #[prost(string, tag = "1")]
        pub file_path: ::prost::alloc::string::String,
        #[prost(int32, tag = "2")]
        pub line: i32,
        #[prost(string, tag = "3")]
        pub message: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub severity: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ComposerContext {
        #[prost(string, repeated, tag = "1")]
        pub files: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, tag = "2")]
        pub mode: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EditTrailContext {
        #[prost(string, repeated, tag = "1")]
        pub edited_files: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, tag = "2")]
        pub description: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ToolResult {
        #[prost(string, tag = "1")]
        pub tool_name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub result: ::prost::alloc::string::String,
        #[prost(bool, tag = "3")]
        pub success: bool,
        #[prost(string, tag = "4")]
        pub error: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Thinking {
        #[prost(string, tag = "1")]
        pub content: ::prost::alloc::string::String,
        #[prost(int32, tag = "2")]
        pub duration_ms: i32,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MessageType {
        Unspecified = 0,
        User = 1,
        Assistant = 2,
        System = 3,
        Tool = 4,
    }
    impl MessageType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MESSAGE_TYPE_UNSPECIFIED",
                Self::User => "MESSAGE_TYPE_USER",
                Self::Assistant => "MESSAGE_TYPE_ASSISTANT",
                Self::System => "MESSAGE_TYPE_SYSTEM",
                Self::Tool => "MESSAGE_TYPE_TOOL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MESSAGE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "MESSAGE_TYPE_USER" => Some(Self::User),
                "MESSAGE_TYPE_ASSISTANT" => Some(Self::Assistant),
                "MESSAGE_TYPE_SYSTEM" => Some(Self::System),
                "MESSAGE_TYPE_TOOL" => Some(Self::Tool),
                _ => None,
            }
        }
    }
}
/// Message header (lightweight metadata)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversationMessageHeader {
    #[prost(string, tag = "1")]
    pub bubble_id: ::prost::alloc::string::String,
    #[prost(enumeration = "conversation_message::MessageType", tag = "2")]
    pub r#type: i32,
    #[prost(int64, tag = "3")]
    pub timestamp: i64,
}
/// Tool call from server to client
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientSideToolV2Call {
    #[prost(string, tag = "1")]
    pub tool_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tool_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub arguments_json: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ClientSideToolV2Call`.
pub mod client_side_tool_v2_call {
    /// Known tool types
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ToolType {
        Unspecified = 0,
        EditFile = 1,
        CreateFile = 2,
        DeleteFile = 3,
        ReadFile = 4,
        RunTerminal = 5,
        SearchFiles = 6,
        ListDir = 7,
        CodebaseSearch = 8,
        GrepSearch = 9,
        FileSearch = 10,
        FetchRules = 11,
        WebSearch = 12,
        Mcp = 13,
    }
    impl ToolType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TOOL_TYPE_UNSPECIFIED",
                Self::EditFile => "TOOL_TYPE_EDIT_FILE",
                Self::CreateFile => "TOOL_TYPE_CREATE_FILE",
                Self::DeleteFile => "TOOL_TYPE_DELETE_FILE",
                Self::ReadFile => "TOOL_TYPE_READ_FILE",
                Self::RunTerminal => "TOOL_TYPE_RUN_TERMINAL",
                Self::SearchFiles => "TOOL_TYPE_SEARCH_FILES",
                Self::ListDir => "TOOL_TYPE_LIST_DIR",
                Self::CodebaseSearch => "TOOL_TYPE_CODEBASE_SEARCH",
                Self::GrepSearch => "TOOL_TYPE_GREP_SEARCH",
                Self::FileSearch => "TOOL_TYPE_FILE_SEARCH",
                Self::FetchRules => "TOOL_TYPE_FETCH_RULES",
                Self::WebSearch => "TOOL_TYPE_WEB_SEARCH",
                Self::Mcp => "TOOL_TYPE_MCP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TOOL_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TOOL_TYPE_EDIT_FILE" => Some(Self::EditFile),
                "TOOL_TYPE_CREATE_FILE" => Some(Self::CreateFile),
                "TOOL_TYPE_DELETE_FILE" => Some(Self::DeleteFile),
                "TOOL_TYPE_READ_FILE" => Some(Self::ReadFile),
                "TOOL_TYPE_RUN_TERMINAL" => Some(Self::RunTerminal),
                "TOOL_TYPE_SEARCH_FILES" => Some(Self::SearchFiles),
                "TOOL_TYPE_LIST_DIR" => Some(Self::ListDir),
                "TOOL_TYPE_CODEBASE_SEARCH" => Some(Self::CodebaseSearch),
                "TOOL_TYPE_GREP_SEARCH" => Some(Self::GrepSearch),
                "TOOL_TYPE_FILE_SEARCH" => Some(Self::FileSearch),
                "TOOL_TYPE_FETCH_RULES" => Some(Self::FetchRules),
                "TOOL_TYPE_WEB_SEARCH" => Some(Self::WebSearch),
                "TOOL_TYPE_MCP" => Some(Self::Mcp),
                _ => None,
            }
        }
    }
}
/// Tool result from client to server
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientSideToolV2Result {
    #[prost(string, tag = "1")]
    pub tool_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub result_json: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub success: bool,
    #[prost(string, tag = "4")]
    pub error_message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExplicitContext {
    #[prost(string, repeated, tag = "1")]
    pub file_paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub folder_paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub web_urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub doc_identifiers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelDetails {
    #[prost(string, tag = "1")]
    pub model_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub provider: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub max_tokens: i32,
    #[prost(float, tag = "4")]
    pub temperature: f32,
    #[prost(bool, tag = "5")]
    pub supports_tools: bool,
    #[prost(bool, tag = "6")]
    pub supports_images: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinterErrors {
    #[prost(message, repeated, tag = "1")]
    pub errors: ::prost::alloc::vec::Vec<linter_errors::LinterError>,
}
/// Nested message and enum types in `LinterErrors`.
pub mod linter_errors {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LinterError {
        #[prost(string, tag = "1")]
        pub file_path: ::prost::alloc::string::String,
        #[prost(int32, tag = "2")]
        pub line: i32,
        #[prost(int32, tag = "3")]
        pub column: i32,
        #[prost(string, tag = "4")]
        pub message: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub severity: ::prost::alloc::string::String,
        #[prost(string, tag = "6")]
        pub code: ::prost::alloc::string::String,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComposerExternalLink {
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub content: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CurrentFileInfo {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub language_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub cursor_line: i32,
    #[prost(int32, tag = "5")]
    pub cursor_column: i32,
    #[prost(message, repeated, tag = "6")]
    pub notebook_cells: ::prost::alloc::vec::Vec<current_file_info::NotebookCell>,
}
/// Nested message and enum types in `CurrentFileInfo`.
pub mod current_file_info {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NotebookCell {
        #[prost(string, tag = "1")]
        pub content: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub language: ::prost::alloc::string::String,
        #[prost(int32, tag = "3")]
        pub index: i32,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileDiffForCompression {
    #[prost(string, tag = "1")]
    pub file_path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub diff: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileDiffHistory {
    #[prost(string, tag = "1")]
    pub file_path: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub diffs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionalRankedContext {
    #[prost(string, tag = "1")]
    pub file_path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
    #[prost(float, tag = "3")]
    pub score: f32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChatQuote {
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub source: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversationSummary {
    #[prost(string, tag = "1")]
    pub summary: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub key_topics: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "3")]
    pub message_count: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserRules {
    #[prost(message, repeated, tag = "1")]
    pub rules: ::prost::alloc::vec::Vec<user_rules::Rule>,
}
/// Nested message and enum types in `UserRules`.
pub mod user_rules {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Rule {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub content: ::prost::alloc::string::String,
        #[prost(bool, tag = "3")]
        pub enabled: bool,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamStart {
    #[prost(string, tag = "1")]
    pub padding: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpanContext {
    #[prost(string, tag = "1")]
    pub trace_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub span_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub trace_flags: u32,
    #[prost(string, tag = "4")]
    pub trace_state: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientChunk {
    #[prost(message, optional, tag = "1")]
    pub request: ::core::option::Option<StreamUnifiedChatRequestWithTools>,
    #[prost(int64, tag = "2")]
    pub chunk_index: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CodeBlock {
    #[prost(string, tag = "1")]
    pub file_path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub start_line: i32,
    #[prost(int32, tag = "4")]
    pub end_line: i32,
    #[prost(string, tag = "5")]
    pub language_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub signatures: ::core::option::Option<code_block::Signatures>,
}
/// Nested message and enum types in `CodeBlock`.
pub mod code_block {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Signatures {
        #[prost(string, repeated, tag = "1")]
        pub function_signatures: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        #[prost(string, repeated, tag = "2")]
        pub class_signatures: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitReference {
    #[prost(string, tag = "1")]
    pub sha: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub author: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub timestamp: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullRequestReference {
    #[prost(string, tag = "1")]
    pub number: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub url: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub state: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitDiff {
    #[prost(string, tag = "1")]
    pub file_path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub diff: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub ref_from: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub ref_to: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestedDiff {
    #[prost(string, tag = "1")]
    pub file_path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub diff: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterpreterResult {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub output: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub language: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub success: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageProto {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "3")]
    pub mime_type: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub alt_text: ::prost::alloc::string::String,
}
