# Security Principles

> **Philosophy**: nixos-cursor enforces secure-by-default practices that other AI tools often neglect.

## Our Commitment

This project prioritizes security over convenience. We believe that AI development tools should set a higher standard for handling authentication and secrets.

### Core Principles

1. **No Plaintext Tokens in Config**
   - API tokens are NEVER stored in `mcp.json` or any Nix store file
   - Tokens are read at runtime from secret files
   - Secret paths are configurable, not hardcoded values

2. **Support Industry-Standard Secret Managers**
   - First-class support for [agenix](https://github.com/ryantm/agenix)
   - First-class support for [sops-nix](https://github.com/Mic92/sops-nix)
   - Compatible with any file-based secrets solution

3. **Encrypted at Rest**
   - Secrets stored in git are encrypted (age encryption)
   - Only authorized users/machines can decrypt
   - Safe to commit encrypted secrets to public repos

4. **Principle of Least Privilege**
   - Secrets are readable only by the owning user
   - File permissions: `0400` (read-only, owner only)
   - Secrets decrypted to ephemeral locations (`/run/secrets/`)

## Why This Matters

Many AI coding assistants and MCP integrations suggest storing API tokens directly in configuration files:

```json
// ❌ DON'T DO THIS - Common but insecure pattern
{
  "mcpServers": {
    "github": {
      "env": {
        "GITHUB_TOKEN": "ghp_xxxxxxxxxxxxx"  // Plaintext token!
      }
    }
  }
}
```

**Problems with this approach:**
- Token visible in plaintext on disk
- Token ends up in Nix store (world-readable)
- Token may be committed to git accidentally
- Token persists in backups, logs, shell history
- No audit trail of token usage

**Our approach:**
```nix
// ✅ DO THIS - Secure pattern
programs.cursor.mcp.github = {
  enable = true;
  tokenFile = config.sops.secrets.github-mcp-token.path;
};
```

**Benefits:**
- Token never written to Nix store
- Token encrypted at rest in git
- Decrypted only when needed, by authorized machines
- Easy rotation (update encrypted file, rebuild)
- Works across multiple machines

## Implementation Details

### Runtime Token Injection

When you configure `tokenFile`, we generate a wrapper script:

```bash
#!/bin/bash
# Auto-generated by nixos-cursor

# Validate secret file exists
if [[ ! -f "/run/secrets/github-mcp-token" ]]; then
  echo "ERROR: Secret file not found" >&2
  exit 1
fi

# Read token at runtime (NOT build time)
export GITHUB_PERSONAL_ACCESS_TOKEN="$(cat /run/secrets/github-mcp-token)"

# Execute MCP server
exec npx -y @modelcontextprotocol/server-github
```

The wrapper:
1. Validates the secret file exists
2. Reads token only when MCP server starts
3. Token never appears in Nix store or mcp.json
4. Helpful error messages if secrets aren't configured

### Multi-Machine Security

With sops-nix or agenix:
- Each machine has its own encryption key (derived from SSH host key)
- Secrets can only be decrypted on authorized machines
- Add new machine: add its key, re-encrypt, deploy
- Remove machine access: remove its key, re-encrypt

## Quick Setup

### Option 1: sops-nix (Recommended)

```nix
# flake.nix
inputs.sops-nix.url = "github:Mic92/sops-nix";

# configuration.nix
sops.secrets.github-mcp-token = {
  key = "github_token";
  owner = "youruser";
};

# home.nix
programs.cursor.mcp.github = {
  enable = true;
  tokenFile = config.sops.secrets.github-mcp-token.path;
};
```

### Option 2: agenix

```nix
# flake.nix  
inputs.agenix.url = "github:ryantm/agenix";

# configuration.nix
age.secrets.github-mcp-token = {
  file = ./secrets/github-token.age;
  owner = "youruser";
};

# home.nix
programs.cursor.mcp.github = {
  enable = true;
  tokenFile = "/run/agenix/github-mcp-token";
};
```

## Token Best Practices

1. **Use Fine-Grained Tokens**
   - GitHub: Use fine-grained PATs, not classic tokens
   - Scope to minimum required permissions
   - Set expiration (90 days recommended)

2. **Rotate Regularly**
   - Set calendar reminders for token expiration
   - Rotation process: generate new → update sops file → deploy → revoke old

3. **Audit Usage**
   - Review GitHub token activity in Settings → Tokens
   - Watch for unexpected API calls

4. **Incident Response**
   - If token exposed: revoke immediately at provider
   - Generate new token, update sops file, deploy
   - Review git history if token was ever in plaintext

## Reporting Security Issues

If you discover a security vulnerability:
1. **DO NOT** open a public GitHub issue
2. Email: distracted.e421@gmail.com
3. Include: description, reproduction steps, potential impact

We aim to respond within 48 hours and fix critical issues within 7 days.

---

*Security is a feature, not an afterthought.*
